package protobuf.interceptor;

import com.google.protobuf.ProtocolMessageEnum;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.CodeBlock.Builder;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.ResolvableType;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.util.ClassUtils;
import protobuf.Configuration;
import protobuf.Protobuf;
import protobuf.ProtobufFileInterceptor;
import protobuf.annotation.ProtobufSource;
import protobuf.field.ProtobufField;
import protobuf.type.GeneralProtobuf;
import protobuf.utils.Optionals;

import javax.lang.model.element.Modifier;
import java.lang.reflect.Method;
import java.util.stream.Collectors;

public class ExtractFromMethodInterceptor implements ProtobufFileInterceptor {

    static Logger logger = LoggerFactory.getLogger(ExtractFromMethodInterceptor.class);

    Configuration configuration;

    public ExtractFromMethodInterceptor(Configuration configuration) {
        this.configuration = configuration;
    }

    @Override
    public boolean supports(Protobuf protobuf) {
        return GeneralProtobuf.class.isAssignableFrom(protobuf.getClass());
    }

    @Override
    public JavaFile intercept(JavaFile javaFile, Protobuf protobuf) throws ClassNotFoundException {
        if(protobuf instanceof GeneralProtobuf){
            Class<?> protobufBeanType = complieAndLoad(javaFile);
            GeneralProtobuf generalProtobuf = (GeneralProtobuf) protobuf;
            TypeSpec typeSpec = javaFile.typeSpec.toBuilder()
                    .addMethod(extractStaticFactoryMethod(generalProtobuf, protobufBeanType))
                    .build();
            return JavaFile.builder(javaFile.packageName,typeSpec).build();
        }
        return javaFile;
    }

    private MethodSpec extractStaticFactoryMethod(GeneralProtobuf protobuf, Class<?> protobufBeanType){
        MethodSpec.Builder builder = MethodSpec.methodBuilder("extractFrom")
                .addParameter(protobuf.protobufType(), "source")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addStatement("$T sink = new $T()", protobufBeanType, protobufBeanType);
        protobuf.getProtobufFields().forEach(field->{
            builder.addCode(parse(field, protobufBeanType));
        });
        return builder.addStatement("return sink")
                .returns(protobufBeanType)
                .build();
    }

    private CodeBlock parse(ProtobufField protobufField, Class<?> protobufBeanType){
        Builder builder = CodeBlock.builder();
        Method beanGetter = ClassUtils.getMethod(protobufBeanType,protobufField.getBeanGetterMethod());
        ResolvableType fieldType = ResolvableType.forMethodReturnType(beanGetter);
        if(fieldType.hasGenerics()){
            // list
            Class<?> singleFieldType = fieldType.getGeneric(0).getRawClass();
            ProtobufSource protobufSource = AnnotatedElementUtils.findMergedAnnotation(singleFieldType, ProtobufSource.class);
            if(protobufSource!=null){
                if(protobufSource.isGenerated()){
                    try {
                        Class<?> fieldProtobufType = protobufSource.protobufClass()==null?
                                ClassUtils.forName(protobufSource.protobufType(),null):
                                protobufSource.protobufClass();
                        //  protobuf
                        if(ProtocolMessageEnum.class.isAssignableFrom(fieldProtobufType)){
                            //  enum
                            builder.add("sink.$NList = source.$N().stream()$W", protobufField.getFieldName(), protobufField.getBeanGetterMethod())
                                    .add(".map(protobuf->$T.valueOf(protobuf.getNumber()))",fieldProtobufType)
                                    .addStatement(".collect(Collectors.toList())");
                        }else{
                            //  general
                            builder.add("sink.$NList = source.$N().stream()$W", protobufField.getFieldName(), protobufField.getBeanGetterMethod())
                                    .add(".map(protobuf->$T.extractFrom(protobuf))",singleFieldType)
                                    .addStatement(".collect($T.toList())", Collectors.class);
                        }
                    } catch (ClassNotFoundException e) {
                        e.printStackTrace();
                    }
                }else{
                    logger.warn(
                        String.format("this protobuf field bean[{}] is not generated by code,%n" +
                                "please add refer code to bean[{}] by yourself!"),singleFieldType,protobufBeanType);
                    builder.add(String.format("//  todo @see %s%n",singleFieldType.getSimpleName()));
                }
            }else{
                //  simple
                builder.addStatement("sink.$NList = source.$N()", protobufField.getFieldName(), protobufField.getBeanGetterMethod());
            }
        }else{
            // simple
            ProtobufSource protobufSource = AnnotatedElementUtils.findMergedAnnotation(fieldType.getRawClass(), ProtobufSource.class);
            if(protobufSource!=null){
                if(protobufSource.isGenerated()){
                    try {
                        Class<?> fieldProtobufType = protobufSource.protobufClass()==null?
                                ClassUtils.forName(protobufSource.protobufType(),null):
                                protobufSource.protobufClass();
                        //  protobuf
                        if(ProtocolMessageEnum.class.isAssignableFrom(fieldProtobufType)){
                            //  enum
                            builder.addStatement(
                                    "$T.forPredicate(source.has$N(),source::$N)$W.map(item->$T.valueOf(item.getNumber()))$W.ifPresent(sink::$N)",
                                    Optionals.class,protobufField.getFieldNameUpperCamel(),protobufField.getBeanGetterMethod(),fieldType.getRawClass(),protobufField.getBeanSetterMethod());
                        }else{
                            //  general
                            builder.addStatement(
                                    "$T.forPredicate(source.has$N(),source::$N)$W.map(protobuf->$T.extractFrom(protobuf))$W.ifPresent(sink::$N)",
                                    Optionals.class,protobufField.getFieldNameUpperCamel(),protobufField.getBeanGetterMethod(),fieldType.getRawClass(),protobufField.getBeanSetterMethod());
                        }
                    } catch (ClassNotFoundException e) {
                        e.printStackTrace();
                    }
                }else{
                    logger.warn(
                            String.format("this protobuf field bean[{}] is not generated by code,%n" +
                                    "please add refer code to bean[{}] by yourself!"),fieldType.getRawClass(),protobufBeanType);
                    builder.add(String.format("//  todo @see %s%n",fieldType.getRawClass().getSimpleName()));
                }
            }else if(fieldType.getRawClass().equals(String.class)){
                //  string
                builder.addStatement(
                        "$T.forPredicateAndNotBlank(source.has$N(),source::$N).ifPresent(sink::$N)",
                        Optionals.class,protobufField.getFieldNameUpperCamel(),protobufField.getBeanGetterMethod(),protobufField.getBeanSetterMethod());
            }else{
                //  simple
                builder.addStatement(
                        "$T.forPredicate(source.has$N(),source::$N).ifPresent(sink::$N)",
                        Optionals.class,protobufField.getFieldNameUpperCamel(),protobufField.getBeanGetterMethod(),protobufField.getBeanSetterMethod());
            }
        }
        return builder.build();
    }
}
